./scripts/sync_ginko_rfun.sh


===== FILE: ./scripts/sync_ginko_rfun.sh =====

#!/usr/bin/env bash
set -euo pipefail

# Sync vendor repository into the app folder.
# This script is intentionally simple: clone if missing, otherwise hard reset to remote.

REPO_URL="https://github.com/CCGenetics/Ginko-Rfun.git"
DEST_DIR="app/scripts/Ginko-Rfun"
BRANCH="main"

if [[ ! -d "$DEST_DIR/.git" ]]; then
  # Fresh clone (or re-clone if the directory exists but is not a git repo).
  rm -rf "$DEST_DIR"
  mkdir -p "$(dirname "$DEST_DIR")"
  git clone --depth 1 --branch "$BRANCH" "$REPO_URL" "$DEST_DIR"
else
  # Update existing clone to match the remote branch exactly.
  git -C "$DEST_DIR" fetch origin "$BRANCH"
  git -C "$DEST_DIR" reset --hard "origin/$BRANCH"
fi
./app/scripts/Ginko-Rfun/download_kobo_attachment.R


===== FILE: ./app/scripts/Ginko-Rfun/download_kobo_attachment.R =====

download_kobo_attachment<-function(kobo_url, local_file_path, username, password){

## Arguments:
# url = url to the file to download. For example for pop data downloaded using the template, the url is stored in the column pop_tabular_file_URL of kobo_clean
# local_file_path  = local path (and file name, including extension) where to save file
# username = your kobo username, should have permissions to download this data
# password = your kobo password
  
### Function
  
# Construct the authentication string in the format "username:password"
auth_string <- paste(username, password, sep = ":")

# Encode the authentication string in base64
encoded_auth_string <- base64enc::base64encode(charToRaw(auth_string))

# Create the authorization header
auth_header <- paste("Basic", encoded_auth_string, sep = " ")

# Create additional headers list
headers <- c("Authorization" = auth_header)

# Download the file with headers (headers are used to add the username and password)
download.file(kobo_url, local_file_path, headers = headers, mode = "wb")
}
./app/scripts/Ginko-Rfun/transform_to_Ne.R


===== FILE: ./app/scripts/Ginko-Rfun/transform_to_Ne.R =====

transform_to_Ne<-function(indNe_data, ratio=0.1){
## This functions gets the Nc data from point or range estimates and transforms it to Ne 
## multiplying for a ratio Ne:Ne (defaults to 0.1 if none provided)
 
## Arguments
## indNe_data as produced by get_indicatorNe_data()
## desired Ne:Nc ratio. Should range 0-1. Defaults to 0.1
  
## output
## Original indNe_data df with more columns for Ne:
# Nc_from_range (conversion of "more than..." to numbers)
# Ne_from_Nc: Ne estimated from NcRange or NcPoint  
# Ne_combined: Ne estimated from Ne if Ne is available, otherwise, from Nc
# NeLower_from_Nc, NeUpper_from_Nc: lower and upper intervals transformed to Ne when data is NcPoint
# Ne_calculated_from: specifies for each population were the data to estimate Ne came from. Options are:  "genetic data", "NcPoint ratio", and "NcRange ratio"
  
  ### Function
  
## check ratio: 
ratio=ratio

if (!is.numeric(ratio) || ratio < 0 || ratio > 1) {
  stop("Invalid argument. Please provide a number within the range 0 to 1, using `.` to delimit decimals.")
} else {
      
    ## process data:
      indNe_data = indNe_data
      
      indNe_data<-indNe_data %>% 
        
        # transform NcRange values to numeric values
        mutate(Nc_from_range = case_when(
              NcRange == "more_5000_bymuch" ~ 10000,
              NcRange == "more_5000" ~ 5500,
              NcRange == "less_5000_bymuch" ~ 500,
              NcRange == "less_5000" ~ 4050,
              NcRange == "range_includes_5000" ~ 5001)) %>% 
        
        # Get Ne from Nc data 
        mutate(Ne_from_Nc = case_when(
                    #if there is NcPoint data, use it multiplying by the ratio
                    !is.na(NcPoint) ~ NcPoint*ratio, 
                    
                    # if there is NcRange data (already converted to numeric values), use it multiplying by the ratio
                    !is.na(Nc_from_range) ~ Nc_from_range * ratio)) %>% 
        
        # Get lower and upper Ne intervals from Nc point data
          # if there is NcPoint LOWER bound data, use it multiplying by the ratio
          mutate(NeLower_from_Nc = case_when(!is.na(NcLower) ~ NcLower*ratio))  %>%
          
          # if there is NcPoint UPPER bound data, use it multiplying by the ratio
          mutate(NeUpper_from_Nc = case_when(!is.na(NcUpper) ~ NcUpper*ratio))  %>%
        
               
        # Get the Ne combining all different sources
        mutate(Ne_combined = if_else(is.na(Ne), # here TRUE means Ne is NA
                                     as.double(Ne_from_Nc), # if genetic data is not available (Ne is NA) then use the Ne estimated from Nc data
                                     as.double(Ne))) %>% # if there is Ne from genetic data, use it
        
        # Create a new variable specifying for each population were the data to estimate Ne came from
        mutate(Ne_calculated_from = if_else(is.na(Ne),  # here TRUE means Ne is NA
                                        
                                        # if Ne is missing check what type of Ncdata was used and use NcPoint/NcRange ratio accordingly
                                        if_else(!is.na(NcPoint), "NcPoint ratio", 
                                                
                                                # if Nc_from_range exists and write "NcRange ratio"
                                                if_else(!is.na(Nc_from_range), "NcRange ratio", 
                                                        
                                                        # If neither NcPoint nor Nc_from_range exists, flag it as missing data
                                                        NA_character_)
                                                ),
                                        
                                        # If Ne is NOT missing, write "genetic" source
                                        "genetic data")
               ) 
        
      print(indNe_data)
    }
}
./app/scripts/Ginko-Rfun/get_indicatorPM_data.R


===== FILE: ./app/scripts/Ginko-Rfun/get_indicatorPM_data.R =====

###
### This R function takes as input the output of the Kobo form "International Genetic Indicator testing" 
### and reformat its in order to have the data in a dataframe useful for estimating 
### Genetic Diversity Indicator PM (the proportion of Populations within species which are Maintained)
### the function also creates new useful variables, 
### like taxon name and if the taxon was assessed only a single time or multiple times
### 

### If you use this script, please check https://ccgenetics.github.io/guidelines-genetic-diversity-indicators/docs/Contact_cite/Contact_cite.html
### for citation guidelines


get_indicatorPM_data<-function(kobo_output=kobo_output){

### Arguments:
  
  # kobo_output = a data frame object read into R from the `.csv` file 
  # resulting from exporting the Kobotoolbox data from the form 
  # "International Genetic Indicator testing" wit the settings explaiend at
  # https://ccgenetics.github.io/guidelines-genetic-diversity-indicators/docs/5_Data_collection/Kobo_toolbox_help.html
  # you can use the raw data, or clean it before.
  
### Needed libraries:  
  
#  library(tidyr)
#  library(dplyr)
#  library(utile.tools)
#  library(stringr)

###
### Function  
###

### Get data
kobo_output<-kobo_output

### Separate data 

# create a variable with the full taxon name if this variable doesn't exist already
# (raw kobo output doesn't include it, but it may exists in a "clean" version of the 
# output if ran through the quality check pipeline)

if("taxon" %in% colnames(kobo_output)){
  print("the data already contained a taxon column, that was used instead of creating a new one")
  
}else {
  kobo_output<-kobo_output %>% 
    mutate(taxon=(utile.tools::paste(genus, species, subspecies_variety, na.rm=TRUE))) %>%
    # remove white space at the end of the name
    mutate(taxon=str_trim(taxon, "right"))
} 

##### Process data already including taxon column

## Add a variable to the metadata stating if the taxon was assessed multiple times or only a single time

# object with duplicated taxa within a single country
# duplicated() is run twice, the second time with  fromLast = TRUE so that 
# the first occurrence is also accounted for, i.e. we can subset all records with the same taxon for a given country
kobo_output_duplicates <- kobo_output[which(duplicated(kobo_output[c('taxon', 'country_assessment')]) | duplicated(kobo_output[c('taxon', 'country_assessment')], fromLast = TRUE)), ]

# if it is a duplicate then tag it as multi_assessment, if it is not duplicated within the country then single
kobo_output <- kobo_output %>% 
  mutate(multiassessment= if_else(
    X_uuid %in% kobo_output_duplicates$X_uuid, "multiassessment", "single_assessment"))


## get indicator PM data
indicatorPM_data <- kobo_output %>% 
  
                 # create variable with year in which assessment was done (based on date the form was compleated)
                 mutate(year_assesment=substr(end,1,4)) %>%
  
                 ## select relevant columns 
                 # taxon and assessment info
                 dplyr::select(country_assessment, taxonomic_group, taxon, scientific_authority,
                               genus, taxon, year_assesment, name_assessor, email_assessor,
                 # indicator 2 data (section 3 of the form)              
                               n_extant_populations, n_extinct_populations, other_populations, time_populations,
                               defined_populations, source_definition_populations, map_populations, map_populations_URL,
                               habitat_decline_area, source_populations, 
                 # kobo validation status
                               X_validation_status,
                # uuid, this is a unique id generated by kobo for each unique record. It will be used to differentiate different records even if the same species is evaluated twice
                               X_uuid,
                # multiassessment
                multiassessment) %>%

                 # change -999 to Na
                         mutate(n_extinct_populations=na_if(n_extinct_populations, -999), 
                                n_extant_populations=na_if(n_extant_populations, -999)) %>%
  
                  # change all "" (empty) cells to NA
                  
  # change all "" (empty) cells to NA. Important: preserve original types (e.g. numeric stays numeric).
  
  mutate(across(everything(), ~{
    if (is.character(.) || is.factor(.)) {
      na_if(as.character(.), "")
    } else {
      .
    }
  }))
                
                # End of function
                           }
                
./app/scripts/Ginko-Rfun/process_attached_files.R


===== FILE: ./app/scripts/Ginko-Rfun/process_attached_files.R =====

### Developed by Luis Castillo and Alicia Mastretta-Yanes


# Define a function to process files
process_attached_files <- function(file_path, kobo_output, delim, skip=0){

## What this function does
#  If information of more than 25 populations was be used to collect data for Ne >500 indicator (Section 5 of the Kobo form) 
# it is possible to use a template to upload data instead of using the kobo form. 
# This functions processes the data stored in a one of those files, and formats it as the output of running the function get_indicator1_data.R  


## Arguments:
# target_file = path to a file that needs to be processed 
              # Normaly the path to this file would be the "original_files_dir", the result of get_attached_files.R creating the directory and moving the files there
              # The file MUST include the Xuuid in the file name  (as resulting from running get_attached_files.R)
# kobo_output = a data frame result with the raw (hundreds of columns) Kobo output as downloaded from Kobo 
# delim = delimiter of the file ("," ";", "\t", etc) to be passed to read_delim()
# skip = Number of lines to skip before reading data. To be pased to read_delim(). Default to 0.

## Needed libraries:
#  library(dplyr)
#  library(readr)
#  library(stringr)
#  library(tools)

  ### Read file
  skip=skip
  delim = delim
  temp_df <- read_delim(file_path, delim = delim, col_names = TRUE, show_col_types = FALSE, skip=skip)
  
  ### Get Xuud from file name
  # get the Xuud ie the characters after the first "__" and the second "__".
  # [1,1] is used because we want the character result
  Xuuid_filename<-str_match(file_path, "(?<=__).*?(?=__)")[1,1] 
  
  
  #######                 Separate data in kobo_output as in get_indicator1 function
  
  # create a variable with the full taxon name if this variable doesn't exist already
  # (raw kobo output doesn't include it, but it may exists in a "clean" version of the 
  # output if ran through the quality check pipeline)
  
  if("taxon" %in% colnames(kobo_output)){
    # the kobo_output data already contained a taxon column, that will be used instead of creating a new one
    
  }else {
    kobo_output<-kobo_output %>% 
      mutate(taxon=(utile.tools::paste(genus, species, subspecies_variety, na.rm=TRUE))) %>%
      # remove white space at the end of the name
      mutate(taxon=str_trim(taxon, "right"))
  } 
  
  ## Add a variable to the metadata stating if the taxon was assessed multiple times or only a single time
  # object with duplicated taxa within a single country
  # duplicated() is run twice, the second time with  fromLast = TRUE so that 
  # the first occurrence is also accounted for, i.e. we can subset all records with the same taxon for a given country
  kobo_output_duplicates <- kobo_output[which(duplicated(kobo_output[c('taxon', 'country_assessment')]) | duplicated(kobo_output[c('taxon', 'country_assessment')], fromLast = TRUE)), ]
  
  # if it is a duplicate then tag it as multi_assessment, if it is not duplicated within the country then single
  kobo_output <- kobo_output %>% 
    mutate(multiassessment= if_else(
      X_uuid %in% kobo_output_duplicates$X_uuid, "multiassessment", "single_assessment"))
  
  ## Process data already including taxon column and multiassessment
  kobo_output <- kobo_output %>% 
    
    # create variable with year in which assessment was done (based on date the form was completed)
    mutate(year_assesment=substr(end,1,4)) %>%
    
    # make sure some variables that seem numbers are actually character,
    # because there may be character and integer values depending on how data was written)
    # for example in IntroductionYear, NeYear and NcYear...
    mutate(across(starts_with("IntroductionYear"), as.character)) %>%
    mutate(across(starts_with("NeYear"), as.character)) %>%
    mutate(across(starts_with("NcYear"), as.character)) %>%
    mutate(across(starts_with("NcRangeDetails"), as.character))
  
    
  ######                              Process attachment file
  
  # columns with population data that should exist
  required_pop_columns <- c("populationID", "PopulationName", "Origin", "IntroductionYear", 
                            "Ne", "NeLower", "NeUpper", "NeYear", "GeneticMarkers", "GeneticMarkersOther", 
                            "MethodNe", "SourceNe", "NcType", "NcYear", "NcMethod", "NcRange", "NcRangeDetails", 
                            "NcPoint", "NcLower", "NcUpper", "SourceNc", "Comments")
  
    ### 1) Check if all required columns are present, if missing, create them
    if(all(required_pop_columns %in% names(temp_df))) {
      print("all requiered population columns are present in the file :)")
      # create working df
      df <- temp_df 
      
         } else {
            ## tell the user and create missing columns as empty
            # create workig df
            df <- temp_df
              
            # check name of missing columns
             missing_columns<-required_pop_columns[!(required_pop_columns %in% names(df))]
             
             # tell the user which columns are missing 
             print(paste("the following column is missing in the file and it will be created as an empity variable:",  missing_columns))
         
             # create empty variable for each missing column
             # Loop through the missing_variables vector and add each column
             for (col_name in missing_columns) {
               df <- df %>%
                 mutate(!!col_name := NA)  # !! operator is used to "unquote" and interpret the col_name as a column name
             }
         }
    
    
    ### 2)  Join population data and metadata (the metadata variables in the attachment file will be replaced from the metadata captured in kobo to assure it is correct)
    # Keep only population data columns and add X_uuid columm
    df <- df %>%
      select(all_of(required_pop_columns)) %>%
      mutate(X_uuid = Xuuid_filename)
    
    # Find matches in "kobo_output" to then merge metadata matching rows with population data
    matching_row <- kobo_output %>%
      filter(X_uuid == Xuuid_filename) %>%
      select(country_assessment, taxonomic_group, time_populations, taxon, 
             scientific_authority, name_assessor, email_assessor, kobo_tabular, genus, species, subspecies_variety,
             X_validation_status, X_uuid, year_assesment, GBIF_taxonID, NCBI_taxonID, multiassessment,
             national_taxonID, defined_populations)
    
    # Join kobo_out metadata and file population data
    df<-left_join(df, matching_row, by = "X_uuid")
    
    ## Further clean population data:
    
    ## Make sure numeric columns are numbers
    for(x in c("Ne", "NeLower", "NeUpper", "NcPoint", "NcLower", "NcUpper")){
      if(class(df[[x]])=="character"){
        print(cat("varible", x, "is stored as character and should be numeric, so this function will: \n
                  1) check if there are (), for instance `86 (95% CI)`, and remove them keeping only the value outside ().\n 
                  2) convert ',' to '' IF more than 3 digits followed the ',' (ie we assumed ',' is separating thousands), OR /n
                     convert ',' to '.' IF 2 digits followed the ',' (ie we assumed ',' is separating decimal points) ; and \n
                  3) use as.numeric(). \n
                  You should check the original data to make sure the transformation was correct"))
        ## 1) remove () if they are:
        df[[x]]<-gsub(pattern="\\s*\\([^\\)]+\\)", replacement="", df[[x]])
        
        ## 2) numeric variables appear as character if  "," was used in the original file 
        
        # Count characters after the first comma 
        characters_after_comma <- nchar(sub("^[^,]*,", "", df[[x]]))
        
        # Change "," for "" if characters_after_comma >= 3, else replace with "."
        df[[x]] <- ifelse(characters_after_comma >= 3, sub(",", "", df[[x]]), sub(",", ".", df[[x]]))
        
        ## transform to numeric
        df[[x]]<-as.numeric(df[[x]])
        
      } else {
        df[[x]]<-as.numeric(df[[x]])}
    }
    
      
  ### 3) NcRange and NcType should have only the values specified in the template. Any other value would be changed to NA.
      
      ## NcRange
      excpected_categories<-c("less_5000", "less_5000_bymuch", "more_5000", "more_5000_bymuch", "range_includes_5000", NA)
      
      condition<-df$NcRange %in% excpected_categories
      
      # message and change data
      if(any(!condition)){ # check if there is at least one FALSE
             print("NcRange values could only be 'less_5000', 'less_5000_bymuch', 'more_5000', 'more_5000_bymuch', 'range_includes_5000'. Other values were found and were changed to NA")
        }
     
       df<- df %>%
        mutate(NcRange = ifelse(condition, NcRange, NA))
      
      ## NcType
      excpected_categories<-c("Nc_point", "Nc_range", NA)
      
      condition<-df$NcType %in% excpected_categories
      
      # message and change data
      if(any(!condition)){ # check if there is at least one FALSE
             print("NcType values could only be 'Nc_point', 'Nc_range'. Other values were found and were changed to NA")
         }
      
      df<- df %>%
        mutate(NcType = ifelse(condition, NcType, NA))
      
      
  ### 4) Rename and fill columns that should not be empty, if needed
      
      # Rename populationId and name column to match desired ind1_data names if they exits
      if ("populationID" %in% colnames(df) && "PopulationName" %in% colnames(df)) {
        df <- df %>%
          rename(population = populationID, Name = PopulationName)
      }
      
      
      ## Population ids should be pop1, pop2.... Since people could have written all sort of things, change them all to pop1, pop2, format
      df <- df %>%
        mutate(population = paste0("pop", row_number()))
      
      
      ## Fix problematic conditionals columns
      
      # if NcPoint data was provided then NcType should exist
      condition<-!is.na(df$NcPoint) & is.na(df$NcType)
      ifelse(condition, print("NcPoint data was provided so NcType should exist but was not provided, setting NcType = `Nc_point` for relevant pops"), "")
      df <- df %>%
        mutate(NcType = ifelse(condition, "Nc_point", NcType))
      
      # if NcRange data was provided then NcType should exist 
      condition<-!is.na(df$NcRange) & is.na(df$NcType)
      ifelse(condition, print("NcRange data was provided so NcType should exist but was not provided, setting NcType = `Nc_range` for relevant pops"), "")
      df <- df %>%
        mutate(NcType = ifelse(condition, "Nc_range", NcType))
      
      # If there is no Nc data, NcMethod and NcType should be NA
      condition<-is.na(df$NcRange) & is.na(df$NcRangeDetails) & is.na(df$NcPoint)
      ifelse(condition, print("If there is no Nc data, NcMethod and NcType should be NA, this was not the case so NA were introduced to replace the value. Check original data to make sure it is correct"), "")
      df <- df %>%
        mutate(NcMethod = ifelse(condition, NA , NcMethod),
               NcType = ifelse(condition, NA , NcType))
      
      
      ## change all "" (empty) cells to NA
      df <- df %>%
        mutate_all(list(~na_if(.,"")))
      
      
    
  ### 5) Change columns to desired order  
       desired_order <- c(
        "country_assessment", "taxonomic_group", "taxon", "scientific_authority", 
        "genus", "year_assesment", "name_assessor", "email_assessor", "kobo_tabular", "defined_populations",
        "time_populations", "X_validation_status", "X_uuid", "multiassessment", "population", 
        "Name", "Origin", "IntroductionYear" , "Ne", "NeLower", "NeUpper", 
        "NeYear", "GeneticMarkers", "GeneticMarkersOther", "MethodNe", "SourceNe", 
        "NcType", "NcYear", "NcMethod", "NcRange", "NcRangeDetails", "NcPoint", 
        "NcLower", "NcUpper", "SourceNc", "Comments")
      
      df <- df %>% select(desired_order)
      

      
  ### 6) Return data
      df   
  }
  
 


./app/scripts/Ginko-Rfun/estimate_indicatorNe.R


===== FILE: ./app/scripts/Ginko-Rfun/estimate_indicatorNe.R =====

### This functions estimates the Ne 500 indicator, ie for each assessment of a taxon it calculates the proportion of populations within it which are above Ne 500. Notice it uses the assessment id `X_uuid` (unique record of a taxon), because a single taxon could be assessed by different countries
##  or more than once with different parameters. The output is a new dataframe with a row per assessment, metadata, new columns used to estimate the indicator (number of pops) and the indicator value.

### If you use this script, please check https://ccgenetics.github.io/guidelines-genetic-diversity-indicators/docs/Contact_cite/Contact_cite.html
### for citation guidelines

estimate_indicatorNe<- function(indNe_data){

## Arguments
## indNe_data: population size data as produced by get_indicatorNe_data() and after running transform_to_Ne()
  

### Function
  
# Estimate indicator Ne 5000 by X_uuid (unique record of a taxon, because a single taxon could be assessed by different countries
# or more than once with different parameters)  
indicatorNe<-indNe_data %>%
  group_by(X_uuid, ) %>%
  summarise(n_pops=n(),
            n_pops_Ne_data=sum(!is.na(Ne_combined)),
            n_pops_more_500=sum(Ne_combined>500, na.rm=TRUE),
            indicatorNe=n_pops_more_500/n_pops_Ne_data) %>%

# join with metadata
left_join(metadata)  

print(indicatorNe)
}./app/scripts/Ginko-Rfun/get_metadata.R


===== FILE: ./app/scripts/Ginko-Rfun/get_metadata.R =====

###
### This R function takes as input the output of the Kobo form "International Genetic Indicator testing" 
### and extracts the metadata for taxa and indicators, in some cases creating new useful variables, 
### like taxon name and if the taxon was assessed only a single time or multiple times
### 

### If you use this script, please check https://ccgenetics.github.io/guidelines-genetic-diversity-indicators/docs/Contact_cite/Contact_cite.html
### for citation guidelines


get_metadata<-function(kobo_output=kobo_output){
  
  ### Arguments:
  
  # kobo_output = a data frame object read into R from the `.csv` file 
  # resulting from exporting the Kobotoolbox data from the form 
  # "International Genetic Indicator testing" wit the settings explaiend at
  # https://ccgenetics.github.io/guidelines-genetic-diversity-indicators/docs/5_Data_collection/Kobo_toolbox_help.html
  # you can use the raw data, or clean it before.
  
  ### Needed libraries:  
  
  #  library(tidyr)
  #  library(dplyr)
  #  library(utile.tools)
  #  library(stringr)
  
  ###
  ### Function  
  ###
  
  ### Get data
  kobo_output<-kobo_output
  
  ### Separate data 
  
  # create a variable with the full taxon name if this variable doesn't exist already
  # (raw kobo output doesn't include it, but it may exists in a "clean" version of the 
  # output if ran through the quality check pipeline)
  
  if("taxon" %in% colnames(kobo_output)){
    print("the data already contained a taxon column, that was used instead of creating a new one")
    
  }else {
    kobo_output<-kobo_output %>% 
      mutate(taxon=(utile.tools::paste(genus, species, subspecies_variety, na.rm=TRUE))) %>%
      # remove white space at the end of the name
      mutate(taxon=str_trim(taxon, "right"))
  } 
  
  # Process data already including taxon column
  
metadata <- kobo_output %>% 
    
    # create variable with year in which assessment was done (based on date the form was compleated)
    mutate(year_assesment=substr(end,1,4)) %>%
    
    ## select relevant columns 
    # taxon and assessment info
    dplyr::select(country_assessment, taxonomic_group, taxon, scientific_authority,
                  genus, year_assesment, name_assessor, email_assessor, common_name, kobo_tabular,
    # kobo validation status
                  X_validation_status,
    # uuid, this is a unique id generated by kobo for each unique record. It will be used to differentiate different records even if the same species is evaluated twice
                  X_uuid,
    # taxon in other databases details
                  GBIF_taxonID,	NCBI_taxonID,	national_taxonID,	source_national_taxonID,
    
    # indicator 2 metadata (section 3 of the form)
                  other_populations, time_populations,
                  defined_populations, source_definition_populations, map_populations, map_populations_URL,
                  habitat_decline_area, source_populations, 
    # indicator 1 metadata (seciton 4 of the form)
                  popsize_data, ne_pops_exists, nc_pops_exists, ratio_exists, species_related, ratio_species_related, 
                  ratio_year, source_popsize_ratios, species_comments, 
    # risk assessments and natural history metadata
                  realm, IUCN_habitat, other_habitat, national_endemic, transboundary_type, other_explain, 
                  country_proportion, species_range, rarity, occurrence_extent, occurrence_area, 
                  pop_fragmentation_level, species_range_comments, global_IUCN, regional_redlist, 
                  other_assessment_status, other_assessment_name, source_status_distribution, 
                  fecundity, semelparous_offpring, reproductive_strategy, reproductive_strategy_other, 
                  adult_age_data, other_reproductive_strategy, longevity_max, longevity_median, longevity_maturity, 
                  longevity_age, life_history_based_on, life_history_sp_basedon, sources_life_history) %>%

     # change all "" (empty) cells to NA
                mutate(across(everything(),~na_if(as.character(.),""))) %>%

    # change "" in kobo_tabular to "kobo" ("" means that question was not answered because the taxon had less populations that the min to trigger tabular)
    mutate(kobo_tabular=ifelse(is.na(kobo_tabular), "kobo", kobo_tabular)) 
  
## Add a variable to the metadata stating if the taxon was assessed multiple times or only a single time
       
    # object with duplicated taxa within a single country
      # duplicated() is run twice, the second time with  fromLast = TRUE so that 
      # the first occurrence is also accounted for, i.e. we can subset all records with the same taxon for a given country
metadata_duplicates <- metadata[which(duplicated(metadata[c('taxon', 'country_assessment')]) | duplicated(metadata[c('taxon', 'country_assessment')], fromLast = TRUE)), ]

    # if it is a duplicate then tag it as multi_assessment, if it is not duplicated within the country then single
metadata <- metadata %>% 
  mutate(multiassessment= if_else(
    X_uuid %in% metadata_duplicates$X_uuid, "multiassessment", "single_assessment"))

  
  # End of function
}

./app/scripts/Ginko-Rfun/get_indicatorNe_data.R


===== FILE: ./app/scripts/Ginko-Rfun/get_indicatorNe_data.R =====

###
### This R function takes as input the output of the Kobo form "International Genetic Indicator testing" 
### and reformat its in order to have the data in a dataframe useful for estimating 
### Genetic Diversity Indicator 1 (the proportion of populations within species with 
###                                a genetically effective size, Ne, greater than 500.)
### 

### If you use this script, please check https://ccgenetics.github.io/guidelines-genetic-diversity-indicators/docs/Contact_cite/Contact_cite.html
### for citation guidelines

get_indicatorNe_data<-function(kobo_output=kobo_output){
  ###
  ### Arguments:
  ###
  
  # kobo_output = a data frame object read into R from the `.csv` file 
  # resulting from exporting the Kobotoolbox data from the form 
  # "International Genetic Indicator testing" wit the settings explaiend at
  # https://ccgenetics.github.io/guidelines-genetic-diversity-indicators/docs/5_Data_collection/Kobo_toolbox_help.html
  # you can use the raw data, or clean it before.
  
  ### Needed libraries:  
  
  #  library(tidyr)
  #  library(dplyr)
  #  library(utile.tools)
  #  library(stringr)
  
  ###
  ### Function  
  ### 
  
  ### Get data
  kobo_output<-kobo_output
  
  ### Separate data 
  
    # create a variable with the full taxon name if this variable doesn't exist already
    # (raw kobo output doesn't include it, but it may exists in a "clean" version of the 
    # output if ran through the quality check pipeline)
    
    if("taxon" %in% colnames(kobo_output)){
       print("the data already contained a taxon column, that was used instead of creating a new one")
        
    }else {
    kobo_output<-kobo_output %>% 
      mutate(taxon=(utile.tools::paste(genus, species, subspecies_variety, na.rm=TRUE))) %>%
        # remove white space at the end of the name
        mutate(taxon=str_trim(taxon, "right"))
    } 
  
   ## Add a variable to the metadata stating if the taxon was assessed multiple times or only a single time
  
  # object with duplicated taxa within a single country
  # duplicated() is run twice, the second time with  fromLast = TRUE so that 
  # the first occurrence is also accounted for, i.e. we can subset all records with the same taxon for a given country
  kobo_output_duplicates <- kobo_output[which(duplicated(kobo_output[c('taxon', 'country_assessment')]) | duplicated(kobo_output[c('taxon', 'country_assessment')], fromLast = TRUE)), ]
  
  # if it is a duplicate then tag it as multi_assessment, if it is not duplicated within the country then single
  kobo_output <- kobo_output %>% 
    mutate(multiassessment= if_else(
      X_uuid %in% kobo_output_duplicates$X_uuid, "multiassessment", "single_assessment"))
  
  
   ### Process data already including taxon column and multiassessment
   
    indicatorNe_data <- kobo_output %>% 
      
    # create variable with year in which assessment was done (based on date the form was completed)
    mutate(year_assesment=substr(end,1,4)) %>%
    
    # make sure some variables that seem numbers are actually character,
    # because there may be character and integer values depending on how data was written)
    # for example in IntroductionYear, NeYear and NcYear...
    mutate(across(starts_with("IntroductionYear"), as.character)) %>%
    mutate(across(starts_with("NeYear"), as.character)) %>%
    mutate(across(starts_with("NcYear"), as.character)) %>%
    mutate(across(starts_with("NcRangeDetails"), as.character)) %>%
      
    ## select relevant columns 
    # taxon and assessment info
    dplyr::select(country_assessment, taxonomic_group, taxon, scientific_authority,
                  genus, taxon, year_assesment, name_assessor, email_assessor, kobo_tabular, 
                  
                  # method to define populations
                  defined_populations,
                  
                  # indicator 1 data               
                  time_populations, Name_pop1:Comments_pop25,
                  
                  # kobo validation status
                  X_validation_status,
                  
                  # uuid, this is a unique id generated by kobo for each unique record. It will be used to differentiate different records even if the same species is evaluated twice
                  X_uuid,
                  
                  # to know if the taxon was assessed multiple times or only a single time
                  multiassessment) %>% 
                  
  ### Get population data as single variables               
    pivot_longer(cols = matches("_pop[0-9]"),
                 names_to=c(".value", "population"),
                 names_sep = "_",
                 values_drop_na = TRUE) %>%
  
  # omit populations w/data (empty because they were not filled, this is ok)  
  filter(Origin!="")  %>% #origin is a mandatory question, so it should be answered, if not, the pop doesn't exist

  # change all "" (empty) cells to NA. Important: preserve original types (e.g. numeric stays numeric).
  
      mutate(across(everything(), ~{
        if (is.character(.) || is.factor(.)) {
          na_if(as.character(.), "")
        } else {
          .
        }
      })) %>% 
      
  # change -999 to Na
  mutate(Ne=na_if(Ne, -999),
         NeLower=na_if(NeLower, -999),
         NeUpper=na_if(NeUpper, -999),
         NcPoint=na_if(NcPoint, -999),
         NcLower=na_if(NcLower, -999),
         NcUpper=na_if(NcUpper, -999)) %>%
      
  # change "" in kobo_tabular to "kobo" ("" means that question was not answered because the taxon had less populations that the min to trigger tabular)
  mutate(kobo_tabular=ifelse(is.na(kobo_tabular), "kobo", kobo_tabular)) 
    
  
    
  
  # End of function
}

./app/scripts/Ginko-Rfun/get_indicatorDNAbased_data.R


===== FILE: ./app/scripts/Ginko-Rfun/get_indicatorDNAbased_data.R =====

###
### This R function takes as input the output of the Kobo form "International Genetic Indicator testing" 
### and reformat its in order to have the data in a dataframe useful for estimating 
### Genetic Diversity Indicator DNA-based monitoring (the number of taxa with genetic monitoring)
### the function also creates new useful variables, 
### like taxon name and if the taxon was assessed only a single time or multiple times
### 

### If you use this script, please check https://ccgenetics.github.io/guidelines-genetic-diversity-indicators/docs/Contact_cite/Contact_cite.html
### for citation guidelines


get_indicatorDNAbased_data<-function(kobo_output=kobo_output){
  
  ### Arguments:
  
  # kobo_output = a data frame object read into R from the `.csv` file 
  # resulting from exporting the Kobotoolbox data from the form 
  # "International Genetic Indicator testing" wit the settings explaiend at
  # https://ccgenetics.github.io/guidelines-genetic-diversity-indicators/docs/5_Data_collection/Kobo_toolbox_help.html
  # you can use the raw data, or clean it before.
  
  ### Needed libraries:  
  
  #  library(tidyr)
  #  library(dplyr)
  #  library(utile.tools)
  #  library(stringr)
  
  ###
  ### Function  
  ###
  
  ### Get data
  kobo_output<-kobo_output
  
  ### Separate data 
  
  # create a variable with the full taxon name if this variable doesn't exist already
  # (raw kobo output doesn't include it, but it may exists in a "clean" version of the 
  # output if ran through the quality check pipeline)
  
  if("taxon" %in% colnames(kobo_output)){
    print("the data already contained a taxon column, that was used instead of creating a new one")
    
  }else {
    kobo_output<-kobo_output %>% 
      mutate(taxon=(utile.tools::paste(genus, species, subspecies_variety, na.rm=TRUE))) %>%
      # remove white space at the end of the name
      mutate(taxon=str_trim(taxon, "right"))
  } 
  
  ## Add a variable to the metadata stating if the taxon was assessed multiple times or only a single time
  
  # object with duplicated taxa within a single country
  # duplicated() is run twice, the second time with  fromLast = TRUE so that 
  # the first occurrence is also accounted for, i.e. we can subset all records with the same taxon for a given country
  kobo_output_duplicates <- kobo_output[which(duplicated(kobo_output[c('taxon', 'country_assessment')]) | duplicated(kobo_output[c('taxon', 'country_assessment')], fromLast = TRUE)), ]
  
  # if it is a duplicate then tag it as multi_assessment, if it is not duplicated within the country then single
  kobo_output <- kobo_output %>% 
    mutate(multiassessment= if_else(
      X_uuid %in% kobo_output_duplicates$X_uuid, "multiassessment", "single_assessment"))
  
  
  ##### Process data already including taxon column
  
  indicator3_data <- kobo_output %>% 
    
    # create variable with year in which assessment was done (based on date the form was compleated)
    mutate(year_assesment=substr(end,1,4)) %>%
    
    ## select relevant columns 
    # taxon and assessment info
    dplyr::select(country_assessment, taxonomic_group, taxon, scientific_authority,
                  genus, taxon, year_assesment, name_assessor, email_assessor,
                 
                   # indicator 3 data (section 7 of the form)              
                  gen_studies, temp_gen_monitoring, gen_monitoring_years, source_genetic_studies,
                  
                  # kobo validation status
                  X_validation_status,
                  # uuid, this is a unique id generated by kobo for each unique record. It will be used to differentiate different records even if the same species is evaluated twice
                  X_uuid,
                  # multiassessment
                  multiassessment) %>%
  
    # change all "" (empty) cells to NA. Important: preserve original types (e.g. numeric stays numeric).
    
    mutate(across(everything(), ~{
      if (is.character(.) || is.factor(.)) {
        na_if(as.character(.), "")
      } else {
        .
      }
    }))
  
  # End of function
}

./app/scripts/Ginko-Rfun/README.md


===== FILE: ./app/scripts/Ginko-Rfun/README.md =====

# README


## Step 1: Quality check
R Note book: [1_Processing_raw_data_quality_test.Rmd](1_Processing_raw_data_quality_test.Rmd)

This step takes as input the output from KoboToolbox in .csv format as downloaded using [these instructions](https://ccgenetics.github.io/guidelines-genetic-diversity-indicators/docs/5_Data_collection/Kobo_toolbox_help.html). 

To run this notebook you have to specify the following two variables at the start of the script:

1) `kobo_file` Output from KoboToolbox in .csv format. For example:

```
kobo_file="International_Genetic_Indicator_testing_V_4.0_-_latest_version_-_False_-_2023-11-02-08-23-26.csv"
```

2) `keep_to_check` to specify if records that need manual review and potentially correction be removed or kept in the exported “clean” data. True to keep, false to filter them. For example:

```
keep_to_check=FALSE #true to keep, false to filter them. Defaults to FALSE
```

The notebook looks for common sources of error and flags those records manual revision by the assessors who capture data from each country. Specifically, it:

1. Filters out records which were marked as "not_approved" in the manual Kobo validation interface (this means country assessors determined the is something wrong with that particular record).
2. Filters out any data entries with the word "test", as they are not real data.
3. Checks for common data capture errors regarding the number of populations:
   * Are 0 correct?
   * should 999 be -999? (missing data label)
   * are extant/extint confused?
5. Check GBIF ID codes to have the right number of digits
6. Check genus, species and subspecies should be a single word.
7. Flags the records that need manual review and potentially correction.
8. Asks the user if she/he wants to keep the taxa flagged in the previous step, or if they should be filtered out.

The output are:
* a report of the quality check
* A .csv file (called `kobo_output_tocheck.csv`) showing **the records that need manual review or corrections**, if any.
* A .csv file (called `kobo_output_clean.csv`) with the data after processing (**records flagged in the previous file may or may not be included according to user choice**).

If any entries need corrections, you have to go back to Kobo and correct the relevant entries. Once you are happy with how data looks, you can proceed to step 2. 

## Step 2: Processing clean data to extract indicator data

R Note book: [2_Processing_clean_extract_indicators_data.Rmd](2_Processing_clean_extract_indicators_data.Rmd)

This notebook performs the following:

1) it re-formats the data as outputed by Kobo to the shape needed to calculate each of the genetic diversity indicators. For example, in the Kobo output each species assessment is a single row, with population data in different columns, but to estimate the Ne indicator it is needed to have data of each population as a row. This script does that format transformation for you.

2) and transforms Nc to Ne based on a custom Nc:Ne ratio.

Notice that at this stage the **indicator values are not calculated**. This script only re-formats the data from the kobo-output so that you can use these data to estimate the indicators by yourself outside R (e.g. in Excel or other software), or continue to step 3 if you want to use the R functions and standard analyses of this repository.

The input is the "clean kobo output" that was first cleaned in step 1. The output are the indicators data ready to be used to estimate the indicators.

* `indNe_data.csv` file: data needed to estimate the Ne 500 indicator.  Each population is a row and the population size data (either Ne or Nc) is provided in different columns. 

* `indPM_data.csv` file: data needed to estimate the PM indicator. Each row is a taxon of a single assessment, and the number of extant and extinct populations are provided.

* `indDNAbased_data` file: data needed to estimate the genetic monitoring indicator (number of species in which genetic diversity has been or is being monitored using DNA-based methods). Each row is a taxon.

* `metadata.csv` file: metadata for taxa and indicators, in some cases creating new useful variables, like taxon name (joining Genus, species, etc) and if the taxon was assessed only a single time or multiple times

### Important note on transforming Nc to Ne data:

In the Kobo form, Ne and Nc data are collected as follows: 

* **Ne (effective population size) from genetic analyses**, ie by software like NeEstimator or Gone. The estimate and its lower an upper limits are stored as numbers in the columns `Ne`, `NeLower`, `NeUpper`. These columns are not modified during processing.

* **Nc (number of mature individuals) from point estimates**, that is quantitative data with or without confidence intervals. The estimate and its lower an upper limits, if available, are stored as numbers in the columns `NcPoint`, `NcLower`, `NcUpper`.

* **Nc (number of mature individuals) from quantitative range or qualitative data**, these are the ranges that in the kobo form show options like "<5,000 by much" or "< 5,000 but not by much (tens or a few hundred less)". The estimate is stored as text in the column `NcRange`. 

This steps uses the function `transform_to_Ne()` to transform Nc estimates and their lower an upper estimates to Ne based on the Nc:Ne ratio the user decides.

For `NcPoint`, `NcLower`, `NcUpper` columns (Nc from point estimates) Nc is transformed to Ne done by multiplying them for the desired ratio. 

For `NcRange`columns (Nc from quantitative range or qualitative data) the range options (text) are first translated to numbers following this rule:

* "more_5000_bymuch" to 10000
* "more_5000" to 5500
* "less_5000_bymuch" to 500
* "less_5000" to 4050
* "range_includes_5000" to 5001

This is stored in the new column `Nc_from_range`. And then, to transform Nc to Ne it is multiplied for the desired ratio.

Regardless if the Nc data was NcPoint or NcRange, after transforming it to Ne it is stored in the column `Ne_from_Nc`. Notice that the column `NcType` (part of the Koboform original variables) states if Nc data came from NcPoint or NcRange. If the type as NcPoint and there were lower and upper intervals, they are also transformed to Ne and stored in the columns `NeLower_from_Nc`, `NeUpper_from_Nc`.

Finally, a new column `Ne_combined` is created combining data from Ne genetic estimates, with the Ne from transforming Nc using the ratio. For this, if both Ne from genetic data and from transforming Nc exist, the Ne from genetic data is given preference. 

For transparency, the column `Ne_calculated_from` specifies for each population were the data to estimate Ne came from. Options are:  "genetic data", "NcPoint ratio", and "NcRange ratio", as explained above.
./app/scripts/wrappers/step4_report.R


===== FILE: ./app/scripts/wrappers/step4_report.R =====

./app/scripts/wrappers/step2_clean_extract.R


===== FILE: ./app/scripts/wrappers/step2_clean_extract.R =====

./app/scripts/wrappers/step3_estimate.R


===== FILE: ./app/scripts/wrappers/step3_estimate.R =====

./app/scripts/wrappers/step1_quality_check.R


===== FILE: ./app/scripts/wrappers/step1_quality_check.R =====

# app/scripts/wrappers/step1_quality_check.R

args <- commandArgs(trailingOnly = TRUE)

if (length(args) < 3) {
  stop("Usage: Rscript step1_quality_check.R <input_csv> <output_dir> <keep_to_check: TRUE|FALSE>")
}

input_csv     <- args[1]
output_dir    <- args[2]
keep_to_check <- as.logical(args[3])

if (!file.exists(input_csv)) stop(paste("Input file does not exist:", input_csv))
if (is.na(keep_to_check)) stop("keep_to_check must be TRUE or FALSE")

dir.create(output_dir, recursive = TRUE, showWarnings = FALSE)

log_path <- file.path(output_dir, "step1_wrapper.log")

log_line <- function(...) {
  msg <- paste0(..., collapse = "")
  cat(msg, "\n")
  cat(msg, "\n", file = log_path, append = TRUE)
}

log_line("=== Step1 wrapper start ===")
log_line("input_csv: ", input_csv)
log_line("output_dir: ", output_dir)
log_line("keep_to_check: ", keep_to_check)

# ---- best-effort locale (helps with string handling) ----------------------
try(Sys.setlocale("LC_ALL", "C.UTF-8"), silent = TRUE)
try(Sys.setlocale("LC_CTYPE", "C.UTF-8"), silent = TRUE)

# ---- ensure required packages exist ---------------------------------------
required <- c(
  "rmarkdown", "knitr",
  "tidyr", "dplyr", "magrittr", "stringr", "ggplot2",
  "utile.tools"
)

installed <- rownames(installed.packages())
to_install <- setdiff(required, installed)

if (length(to_install) > 0) {
  log_line("Installing packages: ", paste(to_install, collapse = ", "))
  install.packages(to_install, repos = "https://cloud.r-project.org")
}

suppressPackageStartupMessages(library(rmarkdown))
suppressPackageStartupMessages(library(knitr))
suppressPackageStartupMessages(library(magrittr))

# ---- locate original Rmd ---------------------------------------------------
rmd_orig <- file.path("scripts", "Ginko-Rfun", "1_Processing_raw_data_quality_test.Rmd")
if (!file.exists(rmd_orig)) {
  log_line("ERROR: Rmd not found: ", rmd_orig)
  quit(status = 1)
}

# ---- convert input CSV to UTF-8 (demo-stable) -----------------------------
# Many Kobo exports come with mixed encodings. We create a UTF-8 copy that
# avoids 'invalid multibyte string' errors during render.
input_utf8 <- file.path(output_dir, "00_raw_data_utf8.csv")

convert_ok <- TRUE
tryCatch({
  raw_lines <- readLines(input_csv, warn = FALSE)

  # Try common legacy encodings -> UTF-8. Use sub="byte" to keep unknown bytes.
  # We prefer Windows-1252 first (common for European quotes/dashes), then latin1.
  conv1 <- iconv(raw_lines, from = "WINDOWS-1252", to = "UTF-8", sub = "byte")
  if (any(is.na(conv1))) {
    conv2 <- iconv(raw_lines, from = "latin1", to = "UTF-8", sub = "byte")
    if (any(is.na(conv2))) {
      # last resort: assume already UTF-8 but with issues; keep bytes
      conv2 <- iconv(raw_lines, from = "UTF-8", to = "UTF-8", sub = "byte")
    }
    writeLines(conv2, input_utf8, useBytes = TRUE)
  } else {
    writeLines(conv1, input_utf8, useBytes = TRUE)
  }

  log_line("Wrote UTF-8 copy: ", input_utf8)
}, error = function(e) {
  convert_ok <<- FALSE
  log_line("ERROR converting input to UTF-8: ", conditionMessage(e))
})

if (!convert_ok || !file.exists(input_utf8)) {
  log_line("ERROR: UTF-8 conversion failed, cannot continue.")
  quit(status = 1)
}

# ---- patch Rmd (override kobo_file and keep_to_check) ---------------------
rmd_patched <- file.path(output_dir, "1_Processing_raw_data_quality_test.PATCHED.Rmd")

rmd_lines <- readLines(rmd_orig, warn = FALSE)

kobo_line <- paste0('kobo_file="', normalizePath(input_utf8, winslash = "/", mustWork = TRUE), '"')
keep_line <- paste0("keep_to_check=", ifelse(keep_to_check, "TRUE", "FALSE"))

rmd_lines <- gsub("^\\s*kobo_file\\s*=\\s*.*$", kobo_line, rmd_lines, perl = TRUE)
rmd_lines <- gsub("^\\s*keep_to_check\\s*=\\s*.*$", keep_line, rmd_lines, perl = TRUE)

writeLines(rmd_lines, rmd_patched)
log_line("Patched Rmd written: ", rmd_patched)
log_line("Patched kobo_file line: ", kobo_line)
log_line("Patched keep_to_check line: ", keep_line)

# ---- render outputs into output_dir ---------------------------------------
old_wd <- getwd()
setwd(output_dir)
on.exit(setwd(old_wd), add = TRUE)

ok <- TRUE
tryCatch({
  log_line("Rendering patched Rmd...")

  rmarkdown::render(
    input = normalizePath(rmd_patched, winslash = "/", mustWork = TRUE),
    output_format = "html_document",
    output_file = "step1_quality_check_report.html",
    quiet = FALSE
  )

  log_line("Render finished.")
}, error = function(e) {
  ok <<- FALSE
  log_line("ERROR during render: ", conditionMessage(e))
})

report_path  <- file.path(output_dir, "step1_quality_check_report.html")
tocheck_path <- file.path(output_dir, "kobo_output_tocheck.csv")
clean_path   <- file.path(output_dir, "kobo_output_clean.csv")

log_line("Report exists: ", file.exists(report_path))
log_line("To-check CSV exists: ", file.exists(tocheck_path))
log_line("Clean CSV exists: ", file.exists(clean_path))
log_line("Log file: ", log_path)
log_line("=== Step1 wrapper end ===")

if (!ok) quit(status = 1)
if (!file.exists(report_path)) quit(status = 1)

quit(status = 0)
./app/content/steps/step4.md


===== FILE: ./app/content/steps/step4.md =====

-----

## Step 4 - Description from a file

TODO: Add step description here.

-----
./app/content/steps/step1.md


===== FILE: ./app/content/steps/step1.md =====

-----------

# Step 1 - Description from a file

TODO: Add step description here.

-----------
./app/content/steps/step3.md


===== FILE: ./app/content/steps/step3.md =====

-----

## Step 3 - Description from a file

TODO: Add step description here.

-----
./app/content/steps/step2.md


===== FILE: ./app/content/steps/step2.md =====

-----

# Step 2 - Description from file

TODO: Add step description here.

-----
./app/content/steps/step0.md


===== FILE: ./app/content/steps/step0.md =====

------

# Step 1 - Description from a file

TODO: Add step description here.

## Upload data!

Upload the raw CSV exported from KoboToolbox.

### What happens next
- The file is copied into the project run directory as `00_raw_data.csv`.
- Step 1 will run a quality check and generate:
  - an HTML report,
  - `kobo_output_tocheck.csv`,
  - `kobo_output_clean.csv`.

### Tips
- Prefer UTF-8 encoded CSV.
- Do not edit column names in the export.

------./app/ui.R


===== FILE: ./app/ui.R =====

# app/ui.R

library(shiny)

source("modules/mod_step_frame.R")
source("modules/mod_step1.R")
source("modules/mod_step2.R")
source("modules/mod_step3.R")
source("modules/mod_step4.R")

step0_md <- file.path("content", "steps", "step0.md")

ui <- fluidPage(
  tags$head(
    tags$link(
      rel = "stylesheet",
      type = "text/css",
      href = "styles.css"
    )
  ),

  tags$h1("Ginko"),

  # ---- STEP 00 ------------------------------------------------------------
  tags$details(
    open = TRUE,
    class = "step-box",

    tags$summary("00 - Upload data"),

    tags$h4("Description"),
    if (file.exists(step0_md)) {
      includeMarkdown(step0_md)
    } else {
      tags$em(paste("Missing markdown file:", step0_md))
    },

    fileInput(
      inputId = "upload_data",
      label = "Upload CSV file",
      accept = ".csv"
    )
  ),

  # ---- STEPS 01–04 --------------------------------------
  mod_step1_ui("step1"),
  mod_step2_ui("step2"),
  mod_step3_ui("step3"),
  mod_step4_ui("step4")
)
./app/server.R


===== FILE: ./app/server.R =====

# app/server.R

library(shiny)

source("modules/mod_step_frame.R")
source("modules/mod_step1.R")
source("modules/mod_step2.R")
source("modules/mod_step3.R")
source("modules/mod_step4.R")

server <- function(input, output, session) {

  # ---- session-scoped sandbox --------------------------------------------
  session_id <- session$token
  base_dir   <- file.path(tempdir(), "ginko", session_id)
  input_dir  <- file.path(base_dir, "input")
  dir.create(input_dir, recursive = TRUE, showWarnings = FALSE)

  session$onSessionEnded(function() {
    unlink(base_dir, recursive = TRUE, force = TRUE)
  })

  # ---- upload -> save to session dir -------------------------------------
  observeEvent(input$upload_data, {
    req(input$upload_data)
    req(input$upload_data$datapath)

    dest_file <- file.path(input_dir, "00_raw_data.csv")

    ok <- file.copy(
      from = input$upload_data$datapath,
      to   = dest_file,
      overwrite = TRUE
    )

    if (!ok) stop("Failed to save uploaded file")

    showNotification(paste("Uploaded ->", dest_file), type = "message")
  })

  # ---- Step 1 (real) ------------------------------------------------------
  mod_step1_server(
    id = "step1",
    paths = list(
      base_dir  = base_dir,
      input_dir = input_dir
    )
  )

  # ---- Steps 2–4 (placeholders; keep your current flow wiring) -----------
  step1_done <- reactiveVal(FALSE)
  step2_done <- reactiveVal(FALSE)
  step3_done <- reactiveVal(FALSE)

  mod_step2_server("step2", state = list(done = step1_done))
  mod_step3_server("step3", state = list(done = step2_done))
  mod_step4_server("step4", state = list(done = step3_done))
}
./app/app.R


===== FILE: ./app/app.R =====

# app/app.R

source("R/00_deps.R")

source("modules/mod_step_frame.R")
source("modules/mod_step1.R")
source("modules/mod_step2.R")
source("modules/mod_step3.R")
source("modules/mod_step4.R")

source("ui.R")
source("server.R")

shiny::shinyApp(
  ui = ui,
  server = server
)
./app/www/styles.css


===== FILE: ./app/www/styles.css =====

/*app/www/styles.css*/

:root{
    --bg-main: #f6f3ea;
    --text-main: #1f2a24;
    --text-muted: #4c5a52;

    --green-main: #1f3d2b;
    --green-hover: #2b5a3c;

    --accent-soft: #cac58b;

    --border-soft: rgba(31, 42, 36, 0.16);
    --shadow-soft: 0 8px 28px rgba(31, 42, 36, 0.10);
}

html, body{
    height: 100%;
}

body{
    background: var(--bg-main);
    color: var(--text-main);
    font-family: "Franklin Gothic Medium","Arial Narrow",Arial,sans-serif;
    letter-spacing: 0.2px;
}

.container-fluid{
    max-width: 980px;
    padding: 28px 20px 60px;
}

h1{
    font-family: "Libre Baskerville", Baskerville, "Times New Roman", Times, serif;
    font-weight: 700;
    letter-spacing: -0.3px;
    margin: 6px 0 22px;
    color: var(--green-main);
    font-size: 44px;
    line-height: 1.08;
}

.btn{
    border-radius: 999px;
    padding: 10px 18px;
    font-weight: 600;
    border: 1px solid transparent;
    box-shadow: none;
}

.btn:focus,
.btn:active:focus,
.btn.active:focus{
    outline: none !important;
    box-shadow: 0 0 0 4px rgba(202, 197, 139, 0.45) !important;
}

.btn-default{
    background: #ffffff;
    color: var(--green-main);
    border-color: var(--border-soft);
    box-shadow: var(--shadow-soft);
}

.btn-default:hover{
    background: #ffffff;
    border-color: rgba(31, 61, 43, 0.35);
    transform: translateY(-1px);
}

.btn-primary{
    background: var(--green-main);
    border-color: var(--green-main);
    color: #ffffff;
    box-shadow: var(--shadow-soft);
}

.btn-primary:hover{
    background: var(--green-hover);
    border-color: var(--green-hover);
    transform: translateY(-1px);
}

.btn-primary:active,
.btn-default:active{
    transform: translateY(0);
}

hr{
    border-top: 1px solid var(--border-soft);
}

a{
    color: var(--green-main);
    text-decoration: underline;
    text-decoration-color: rgba(31, 61, 43, 0.35);
    text-underline-offset: 3px;
}

a:hover{
    color: var(--green-hover);
    text-decoration-color: rgba(31, 61, 43, 0.65);
}
/* app/www/styles.css */

.step-box {
    margin-bottom: 20px;
    padding: 12px 16px;
    border: 1px solid rgba(0,0,0,0.15);
    border-radius: 8px;
    background: #fafafa;
}

.step-box summary {
    font-weight: 700;
    font-size: 16px;
    cursor: pointer;
    margin-bottom: 8px;
}

.step-box h4 {
    margin-top: 12px;
}
./app/R/00_deps.R


===== FILE: ./app/R/00_deps.R =====

# app/R/00_deps.R

packages <- c(
  "shiny",
  "markdown",
  "rmarkdown",
  "knitr",

  # Ginko step1 Rmd deps
  "tidyr",
  "dplyr",
  "magrittr",
  "stringr",
  "ggplot2",
  "utile.tools"
)

installed <- rownames(installed.packages())
to_install <- setdiff(packages, installed)

if (length(to_install) > 0) {
  install.packages(
    to_install,
    repos = "https://cloud.r-project.org"
  )
}
./app/modules/mod_step3.R


===== FILE: ./app/modules/mod_step3.R =====

# app/modules/mod_step3.R

library(shiny)

source("modules/mod_step_frame.R")
step3_md <- file.path("content", "steps", "step3.md")

mod_step3_ui <- function(id) {
  ns <- NS(id)

  step_frame_ui(
    id = id,
    title = "03 - Estimate indicators",

    description_ui = tagList(
      tags$p(
        "Calculates genetic diversity indicators required by the ",
        "Global Biodiversity Framework (Ne 500, PM, DNA-based)."
      ),
      includeMarkdown(step3_md)
    ),

    params_ui = tagList(
      numericInput(
        inputId = ns("ne_threshold"),
        label = "Ne threshold",
        value = 500,
        min = 1
      )
    ),

    process_ui = actionButton(
      inputId = ns("process"),
      label = "Process"
    ),

    result_ui = tagList(
      tags$p("Step 3 outputs (placeholder)."),
      downloadButton(ns("download_output"), "Download output")
    )
  )
}

mod_step3_server <- function(id, state) {
  moduleServer(id, function(input, output, session) {

    observeEvent(input$process, {
      state$done(TRUE)
      showNotification(
        paste("Step 3 finished (placeholder). Ne threshold =", input$ne_threshold),
        type = "message"
      )
    })

    output$download_output <- downloadHandler(
      filename = function() {
        "step3_output_placeholder.txt"
      },
      content = function(file) {
        writeLines(
          paste("Placeholder output for Step 3. Ne threshold:", input$ne_threshold),
          con = file
        )
      }
    )
  })
}
./app/modules/mod_step1.R


===== FILE: ./app/modules/mod_step1.R =====

# app/modules/mod_step1.R

library(shiny)

source("modules/mod_step_frame.R")
step1_md <- file.path("content", "steps", "step1.md")
mod_step1_ui <- function(id) {
  ns <- NS(id)

  step_frame_ui(
    id = id,
    title = "01 - Raw data quality check",

    description_ui = tagList(
      tags$p("Runs the Step 1 quality check from the Ginko-Rfun repository."),
      tags$p("Outputs: report HTML + kobo_output_tocheck.csv + kobo_output_clean.csv."),
      includeMarkdown(step1_md)
    ),


    params_ui = tagList(
      checkboxInput(
        inputId = ns("keep_to_check"),
        label = "Keep records flagged for manual review in the CLEAN output (keep_to_check)",
        value = FALSE
      )
    ),

    process_ui = actionButton(
      inputId = ns("process"),
      label = "Process"
    ),

    result_ui = tagList(
      tags$h5("Run status"),
      verbatimTextOutput(ns("run_status")),

      tags$h5("Report preview"),
      uiOutput(ns("report_preview")),

      downloadButton(ns("download_tocheck"), "Download to-check CSV"),
      downloadButton(ns("download_clean"), "Download clean CSV"),
      downloadButton(ns("download_report"), "Download report (HTML)"),
      downloadButton(ns("download_log"), "Download step log")
    )
  )
}

mod_step1_server <- function(id, paths) {
  moduleServer(id, function(input, output, session) {

    tocheck_path <- reactiveVal(NULL)
    clean_path   <- reactiveVal(NULL)
    report_path  <- reactiveVal(NULL)
    log_path     <- reactiveVal(NULL)

    run_status   <- reactiveVal("Not run yet.")
    run_id       <- reactiveVal(0)

    observeEvent(input$process, {

      input_csv <- file.path(paths$input_dir, "00_raw_data.csv")
      if (!file.exists(input_csv)) {
        showNotification("Step 1: missing uploaded file 00_raw_data.csv", type = "error")
        return()
      }

      step_out_dir <- file.path(paths$base_dir, "step1")
      dir.create(step_out_dir, recursive = TRUE, showWarnings = FALSE)

      cmd <- "Rscript"
      args <- c(
        "scripts/wrappers/step1_quality_check.R",
        input_csv,
        step_out_dir,
        as.character(input$keep_to_check)
      )

      run_status(paste0(
        "Running:\n", cmd, " ", paste(args, collapse = " "), "\n"
      ))

      res <- system2(
        command = cmd,
        args = args,
        stdout = TRUE,
        stderr = TRUE
      )
      status <- attr(res, "status")
      if (is.null(status)) status <- 0

      # expected outputs
      tocheck <- file.path(step_out_dir, "kobo_output_tocheck.csv")
      clean   <- file.path(step_out_dir, "kobo_output_clean.csv")
      report  <- file.path(step_out_dir, "step1_quality_check_report.html")
      logf    <- file.path(step_out_dir, "step1_wrapper.log")

      tocheck_path(tocheck)
      clean_path(clean)
      report_path(report)
      log_path(logf)
      run_id(run_id() + 1)

      # always persist system2 output as well
      sys_log <- file.path(step_out_dir, "step1_system2.log")
      writeLines(res, con = sys_log)

      status_msg <- paste0(
        "Exit status: ", status, "\n",
        "system2 log: ", sys_log, "\n",
        "wrapper log: ", logf, "\n",
        "report exists: ", file.exists(report), "\n",
        "tocheck exists: ", file.exists(tocheck), "\n",
        "clean exists: ", file.exists(clean), "\n"
      )
      run_status(status_msg)

      if (status != 0 || !file.exists(report)) {
        showNotification("Step 1: report was not generated (check logs)", type = "error")
      } else {
        showNotification("Step 1 finished", type = "message")
      }
    })

    output$run_status <- renderText({
      run_id()
      run_status()
    })

    output$report_preview <- renderUI({
      run_id()
      req(report_path())
      if (file.exists(report_path())) {
        tags$code(report_path())
      } else {
        tags$em("No report generated yet. Download logs to see why.")
      }
    })

    output$download_tocheck <- downloadHandler(
      filename = function() "kobo_output_tocheck.csv",
      content = function(file) {
        req(tocheck_path())
        if (!file.exists(tocheck_path())) stop("Missing kobo_output_tocheck.csv")
        file.copy(tocheck_path(), file)
      }
    )

    output$download_clean <- downloadHandler(
      filename = function() "kobo_output_clean.csv",
      content = function(file) {
        req(clean_path())
        if (!file.exists(clean_path())) stop("Missing kobo_output_clean.csv")
        file.copy(clean_path(), file)
      }
    )

    output$download_report <- downloadHandler(
      filename = function() "step1_quality_check_report.html",
      content = function(file) {
        req(report_path())
        if (!file.exists(report_path())) stop("Missing report HTML")
        file.copy(report_path(), file)
      }
    )

    output$download_log <- downloadHandler(
      filename = function() "step1_wrapper.log",
      content = function(file) {
        req(log_path())
        if (!file.exists(log_path())) stop("Missing wrapper log")
        file.copy(log_path(), file)
      }
    )
  })
}
./app/modules/mod_step2.R


===== FILE: ./app/modules/mod_step2.R =====

# app/modules/mod_step2.R

library(shiny)

source("modules/mod_step_frame.R")
step2_md <- file.path("content", "steps", "step2.md")

mod_step2_ui <- function(id) {
  ns <- NS(id)

  step_frame_ui(
    id = id,
    title = "02 - Clean & extract indicators data",

    description_ui = tagList(
      tags$p(
        "Transforms quality-checked raw data into indicator-specific datasets ",
        "required for further analysis (Ne, PM, DNA-based)."
      ),
      includeMarkdown(step2_md)
    ),

    params_ui = tags$p("This step does not require any parameters."),

    process_ui = actionButton(
      inputId = ns("process"),
      label = "Process"
    ),

    result_ui = tagList(
      tags$p("Step 2 outputs (placeholder)."),
      downloadButton(ns("download_output"), "Download output")
    )
  )
}

mod_step2_server <- function(id, state) {
  moduleServer(id, function(input, output, session) {

    observeEvent(input$process, {
      state$done(TRUE)
      showNotification("Step 2 finished (placeholder)", type = "message")
    })

    output$download_output <- downloadHandler(
      filename = function() {
        "step2_output_placeholder.txt"
      },
      content = function(file) {
        writeLines("Placeholder output for Step 2.", con = file)
      }
    )
  })
}
./app/modules/mod_step4.R


===== FILE: ./app/modules/mod_step4.R =====

# app/modules/mod_step4.R

library(shiny)

source("modules/mod_step_frame.R")
step4_md <- file.path("content", "steps", "step4.md")

mod_step4_ui <- function(id) {
  ns <- NS(id)

  step_frame_ui(
    id = id,
    title = "04 - Country report",

    description_ui = tagList(
      tags$p(
        "Generates a country-level report summarizing genetic diversity indicators."
      ),
      includeMarkdown(step4_md)
    ),

    params_ui = tagList(
      textInput(
        inputId = ns("country_name"),
        label = "Country name",
        value = ""
      )
    ),

    process_ui = actionButton(
      inputId = ns("process"),
      label = "Process"
    ),

    result_ui = tagList(
      tags$p("Step 4 outputs (placeholder)."),
      downloadButton(ns("download_report"), "Download report")
    )
  )
}

mod_step4_server <- function(id, state) {
  moduleServer(id, function(input, output, session) {

    observeEvent(input$process, {
      state$done(TRUE)
      showNotification(
        paste(
          "Step 4 finished (placeholder). Country:",
          ifelse(nzchar(input$country_name), input$country_name, "(not specified)")
        ),
        type = "message"
      )
    })

    output$download_report <- downloadHandler(
      filename = function() {
        "step4_country_report_placeholder.txt"
      },
      content = function(file) {
        writeLines(
          paste("Placeholder country report. Country:", input$country_name),
          con = file
        )
      }
    )
  })
}
./app/modules/mod_step_frame.R


===== FILE: ./app/modules/mod_step_frame.R =====

# app/modules/mod_step_frame.R

step_frame_ui <- function(
  id,
  title,
  description_ui,
  params_ui = NULL,
  process_ui,
  result_ui = NULL
) {
  ns <- NS(id)

  tags$details(
    class = "step-box",
    tags$summary(title),

    tags$div(
      class = "step-content",

      tags$h4("Description"),
      description_ui,

      tags$h4("Parameters"),
      if (is.null(params_ui)) tags$p("No parameters.") else params_ui,

      tags$h4("Process"),
      process_ui,

      tags$h4("Result"),
      if (is.null(result_ui)) tags$p("No results yet.") else result_ui
    )
  )
}
./docker-compose.yml


===== FILE: ./docker-compose.yml =====

# docker-compose.yml
version: "3.9"

services:
  ginko:
    platform: linux/amd64
    build:
      context: .
      dockerfile: docker/Dockerfile
    ports:
      - "3838:3838"
    volumes:
      - ./app:/app
./README.md


===== FILE: ./README.md =====

# Ginko App — Temporary Repository

⚠️ **Important notice**

This repository is **temporary**.  
Once the access issues are resolved, the project will be **moved to the official repository**:

👉 https://github.com/CCGenetics/Ginko-app

---

## Development Workflow

- Active development is done on **separate feature branches**.
- Each new feature, fix, or experiment should be implemented in its own branch.
- Once ready, changes are **merged into the `main` branch** via a merge request / pull request.
- The `main` branch is considered **stable** and is used for deployment.

---

## Step Descriptions

Documentation and descriptions for individual processing steps are located in:

app/content/steps

Each step has its own Markdown file describing inputs, outputs, and expected behavior.

---

## Live Application

The application is currently available at:

👉 https://mrk.quest/

---

## Deployment & Builds

- Every **merge into the `main` branch** triggers an automatic deployment.
- The application is **rebuilt from scratch on the production server** after each merge.
- Deployment is handled automatically via CI/CD.

---

## Status

This setup is intended for **testing and development purposes** until the repository migration is completed.
./.github/workflows/deploy-prod.yml


===== FILE: ./.github/workflows/deploy-prod.yml =====

name: Deploy to production

on:
  push:
    branches: [ "main" ]

concurrency:
  group: deploy-prod
  cancel-in-progress: true

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Deploy over SSH (git pull + compose restart)
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.PROD_HOST }}
          username: ${{ secrets.PROD_USER }}
          key: ${{ secrets.PROD_SSH_KEY }}
          port: ${{ secrets.PROD_SSH_PORT || 22 }}
          script: |
            set -euo pipefail
          
            cd /opt/ginko
          
            echo "== Sync main =="
            git fetch origin --prune
            git reset --hard origin/main
          
            echo "== Restart production compose =="
            docker compose -f docker-compose.prod.yml restart
          
            echo "== Done. Current commit =="
            git rev-parse --short HEAD
            docker compose -f docker-compose.prod.yml ps

./docker-compose.prod.yml


===== FILE: ./docker-compose.prod.yml =====

version: "3.9"

services:
  ginko:
    platform: linux/amd64
    build:
      context: .
      dockerfile: docker/Dockerfile
    # expose only locally; public traffic goes through Caddy
    ports:
      - "127.0.0.1:3838:3838"
    volumes:
      - ./app:/app
    restart: unless-stopped

  caddy:
    image: caddy:2
    restart: unless-stopped
    depends_on:
      - ginko
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./Caddyfile:/etc/caddy/Caddyfile:ro
      - caddy_data:/data
      - caddy_config:/config

volumes:
  caddy_data:
  caddy_config:
